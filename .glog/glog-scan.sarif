{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-ca494392-856e-428a-9123-a6bea779b5d9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability identified with the `memcpy` function in C++ arises from improper handling of memory operations, which can lead to buffer overflows. This occurs when the destination buffer is not large enough to hold the data being copied from the source buffer, potentially leading to memory corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `std::copy` or `std::memmove` which provide better safety guarantees.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability in the specific code snippet:\n\n```cpp\nmemcpy(enums.get(), pnames, pnames_size);\n```\n\nEnsure that `enums` has enough allocated memory to hold `pnames_size` bytes. Here is a safer version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <memory>  // Required for std::unique_ptr\n\n// Assuming enums is a std::unique_ptr<char[]> and pnames is a char*\nstd::unique_ptr<char[]> enums = std::make_unique<char[]>(pnames_size);\nif (enums && pnames) {\n    std::memcpy(enums.get(), pnames, pnames_size);\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following libraries are required:\n\n- `<cstring>`: For `memcpy`.\n- `<memory>`: For `std::unique_ptr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9628f3bf-c093-4eaa-8187-6c56d9a4cdf4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe `strlen` function in C and C++ is used to determine the length of a null-terminated string. However, if the input to `strlen` is not properly validated, it can lead to vulnerabilities such as buffer overflows or segmentation faults. This is because `strlen` does not check the bounds of the input string, and if the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially accessing memory out of bounds.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input strings to ensure they are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` which allows specifying a maximum length to prevent reading out of bounds.\n3. **Memory Management**: Ensure that all strings are properly allocated and null-terminated.\n4. **Static Analysis**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring>\n\n// Original vulnerable code\n// size_t length = strlen(name);\n\n// Fixed code using strnlen\nsize_t safe_strlen(const char* name, size_t max_len) {\n    return strnlen(name, max_len);\n}\n\nint main() {\n    const char* name = \"example\";\n    size_t max_len = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(name, max_len);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-d2f6bfbf-c9a7-4f5c-8ac6-9bf26d6f3079",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe `strlen` function in C and C++ is used to determine the length of a null-terminated string. However, if the input to `strlen` is not properly validated, it can lead to vulnerabilities such as buffer overflows or segmentation faults. This is because `strlen` does not check the bounds of the input string, and if the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially accessing memory out of bounds.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input strings to ensure they are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` which allows specifying a maximum length to prevent reading out of bounds.\n3. **Memory Management**: Ensure that all strings are properly allocated and null-terminated.\n4. **Static Analysis**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring>\n\n// Original vulnerable code\n// size_t length = strlen(name);\n\n// Fixed code using strnlen\nsize_t safe_strlen(const char* name, size_t max_len) {\n    return strnlen(name, max_len);\n}\n\nint main() {\n    const char* name = \"example\";\n    size_t max_len = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(name, max_len);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-4bafba70-a999-4fca-9214-8963914d5bce",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, leading to potential buffer overflows. This occurs when the size of the source data exceeds the size of the destination buffer, causing memory corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Always ensure that the size of the source data does not exceed the size of the destination buffer.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or C++ standard library functions that perform bounds checking.\n3. **Implement Bounds Checking**: Manually check the sizes before performing memory operations.\n4. **Adopt Secure Coding Practices**: Regularly review and test code for vulnerabilities.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\nvoid safeMemcpy(void* dest, const void* src, size_t destSize, size_t srcSize) {\n    // Ensure that we do not copy more than the destination can hold\n    size_t copySize = std::min(destSize, srcSize);\n    memcpy(dest, src, copySize);\n}\n\n// Example usage\nvoid exampleUsage() {\n    const size_t pixels_size = 100;\n    char pixels[pixels_size];\n    const char* data = \"Example data that might be too large for the buffer\";\n    size_t data_size = strlen(data) + 1; // +1 for null terminator\n\n    safeMemcpy(pixels, data, pixels_size, data_size);\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `memcpy`.\n- `<algorithm>`: Required for `std::min`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-dc4b72c3-e709-4c9d-ac34-a5058c3fad7c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, leading to potential buffer overflows. This can occur when the destination buffer is not large enough to hold the data being copied from the source buffer. In the provided code snippet, `memcpy(name.key, mailbox.name, sizeof(mailbox.name))`, the size of the data being copied is determined by `sizeof(mailbox.name)`, which may exceed the size of `name.key`, leading to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Buffer Sizes**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `strncpy` or `memmove` that allow specifying the maximum number of bytes to copy.\n3. **Boundary Checks**: Implement boundary checks to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough and use a safer function that limits the number of bytes copied:\n\n```cpp\n#include <cstring> // Required for memcpy\n\n// Assuming name.key and mailbox.name are character arrays\n// Define the maximum size for name.key\nconst size_t NAME_KEY_SIZE = sizeof(name.key);\n\n// Use strncpy to safely copy data\nstrncpy(name.key, mailbox.name, NAME_KEY_SIZE - 1);\n\n// Null-terminate the destination buffer\nname.key[NAME_KEY_SIZE - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using functions like `memcpy` and `strncpy`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4ef49997-41d5-4526-ba44-4c9527a8df80",
              "help": {
                "text": "",
                "markdown": "### Description of \"Unsecured URL\" Vulnerability in C++ Programming Language\n\nThe \"Unsecured URL\" vulnerability occurs when a C++ application constructs URLs without proper validation or sanitization, potentially leading to security issues such as information leakage, man-in-the-middle attacks, or redirection to malicious sites. This vulnerability is particularly concerning when URLs are constructed using user input or other untrusted data sources.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate and sanitize user inputs before using them to construct URLs.\n2. **Use Secure Protocols**: Prefer HTTPS over HTTP to ensure data is encrypted during transmission.\n3. **Whitelist URLs**: Implement a whitelist of allowed URLs or domains to prevent redirection to malicious sites.\n4. **Library Functions**: Use well-tested libraries for URL parsing and construction to avoid common pitfalls.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to mitigate the \"Unsecured URL\" vulnerability in C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <regex>\n#include <stdexcept>\n\n// Function to validate URL\nbool isValidURL(const std::string& url) {\n    const std::regex url_regex(\n        R\"(^https:\\/\\/[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(\\/\\S*)?$)\",\n        std::regex::extended\n    );\n    return std::regex_match(url, url_regex);\n}\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter a URL: \";\n    std::cin >> userInput;\n\n    try {\n        if (!isValidURL(userInput)) {\n            throw std::invalid_argument(\"Invalid URL format or insecure protocol.\");\n        }\n        std::cout << \"URL is valid and secure: \" << userInput << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<string>`: For string manipulation.\n- `<regex>`: For regular expression operations.\n- `<stdexcept>`: For exception handling.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-601: URL Redirection to Untrusted Site ('Open Redirect')](https://cwe.mitre.org/data/definitions/601.html)\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "glog-f4526d29-2dc5-4827-a620-c53e4651881b",
              "help": {
                "text": "",
                "markdown": "### Description of \"Unsecured URL\" Vulnerability in C++ Programming Language\n\nThe \"Unsecured URL\" vulnerability occurs when a C++ application constructs URLs without proper validation or sanitization, potentially leading to security issues such as information leakage, man-in-the-middle attacks, or redirection to malicious sites. This vulnerability is particularly concerning when URLs are constructed using user input or other untrusted data sources.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate and sanitize user inputs before using them to construct URLs.\n2. **Use Secure Protocols**: Prefer HTTPS over HTTP to ensure data is encrypted during transmission.\n3. **Whitelist URLs**: Implement a whitelist of allowed URLs or domains to prevent redirection to malicious sites.\n4. **Library Functions**: Use well-tested libraries for URL parsing and construction to avoid common pitfalls.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to mitigate the \"Unsecured URL\" vulnerability in C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <regex>\n#include <stdexcept>\n\n// Function to validate URL\nbool isValidURL(const std::string& url) {\n    const std::regex url_regex(\n        R\"(^https:\\/\\/[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(\\/\\S*)?$)\",\n        std::regex::extended\n    );\n    return std::regex_match(url, url_regex);\n}\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter a URL: \";\n    std::cin >> userInput;\n\n    try {\n        if (!isValidURL(userInput)) {\n            throw std::invalid_argument(\"Invalid URL format or insecure protocol.\");\n        }\n        std::cout << \"URL is valid and secure: \" << userInput << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<string>`: For string manipulation.\n- `<regex>`: For regular expression operations.\n- `<stdexcept>`: For exception handling.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-601: URL Redirection to Untrusted Site ('Open Redirect')](https://cwe.mitre.org/data/definitions/601.html)\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "glog-47334aa6-bad3-4481-bb64-970700c75adc",
              "help": {
                "text": "",
                "markdown": "### Description of \"Unsecured URL\" Vulnerability in C++ Programming Language\n\nThe \"Unsecured URL\" vulnerability occurs when a C++ application constructs URLs without proper validation or sanitization, potentially leading to security issues such as information leakage, man-in-the-middle attacks, or redirection to malicious sites. This vulnerability is particularly concerning when URLs are constructed using user input or other untrusted data sources.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate and sanitize user inputs before using them to construct URLs.\n2. **Use Secure Protocols**: Prefer HTTPS over HTTP to ensure data is encrypted during transmission.\n3. **Whitelist URLs**: Implement a whitelist of allowed URLs or domains to prevent redirection to malicious sites.\n4. **Library Functions**: Use well-tested libraries for URL parsing and construction to avoid common pitfalls.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to mitigate the \"Unsecured URL\" vulnerability in C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <regex>\n#include <stdexcept>\n\n// Function to validate URL\nbool isValidURL(const std::string& url) {\n    const std::regex url_regex(\n        R\"(^https:\\/\\/[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(\\/\\S*)?$)\",\n        std::regex::extended\n    );\n    return std::regex_match(url, url_regex);\n}\n\nint main() {\n    std::string userInput;\n    std::cout << \"Enter a URL: \";\n    std::cin >> userInput;\n\n    try {\n        if (!isValidURL(userInput)) {\n            throw std::invalid_argument(\"Invalid URL format or insecure protocol.\");\n        }\n        std::cout << \"URL is valid and secure: \" << userInput << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<string>`: For string manipulation.\n- `<regex>`: For regular expression operations.\n- `<stdexcept>`: For exception handling.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-601: URL Redirection to Untrusted Site ('Open Redirect')](https://cwe.mitre.org/data/definitions/601.html)\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-ca494392-856e-428a-9123-a6bea779b5d9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                },
                "region": {
                  "startLine": 8924,
                  "startColumn": 2,
                  "endLine": 8924,
                  "endColumn": 42,
                  "charOffset": 304040,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy(enums.get(), pnames, pnames_size)",
                    "rendered": {
                      "text": "memcpy(enums.get(), pnames, pnames_size)",
                      "markdown": "`memcpy(enums.get(), pnames, pnames_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 304040,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s(enums.get(), <size of enums.get()>,  pnames,  pnames_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9628f3bf-c093-4eaa-8187-6c56d9a4cdf4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                },
                "region": {
                  "startLine": 4493,
                  "startColumn": 44,
                  "endLine": 4493,
                  "endColumn": 56,
                  "charOffset": 155053,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(name)",
                    "rendered": {
                      "text": "strlen(name)",
                      "markdown": "`strlen(name)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 155053,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(name, <size of name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 155053,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(name, <size of name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d2f6bfbf-c9a7-4f5c-8ac6-9bf26d6f3079",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                },
                "region": {
                  "startLine": 4435,
                  "startColumn": 44,
                  "endLine": 4435,
                  "endColumn": 56,
                  "charOffset": 153081,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(name)",
                    "rendered": {
                      "text": "strlen(name)",
                      "markdown": "`strlen(name)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 153081,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(name, <size of name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 153081,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(name, <size of name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4bafba70-a999-4fca-9214-8963914d5bce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                },
                "region": {
                  "startLine": 6972,
                  "startColumn": 4,
                  "endLine": 6972,
                  "endColumn": 37,
                  "charOffset": 237227,
                  "charLength": 33,
                  "snippet": {
                    "text": "memcpy(pixels, data, pixels_size)",
                    "rendered": {
                      "text": "memcpy(pixels, data, pixels_size)",
                      "markdown": "`memcpy(pixels, data, pixels_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 237227,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "memcpy_s(pixels, <size of pixels>,  data,  pixels_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dc4b72c3-e709-4c9d-ac34-a5058c3fad7c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                },
                "region": {
                  "startLine": 3261,
                  "startColumn": 2,
                  "endLine": 3261,
                  "endColumn": 53,
                  "charOffset": 113191,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(name.key, mailbox.name, sizeof(mailbox.name)",
                    "rendered": {
                      "text": "memcpy(name.key, mailbox.name, sizeof(mailbox.name)",
                      "markdown": "`memcpy(name.key, mailbox.name, sizeof(mailbox.name)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 113191,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(name.key, <size of name.key>,  mailbox.name,  sizeof(mailbox.name)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4ef49997-41d5-4526-ba44-4c9527a8df80",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Insecure URL"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                },
                "region": {
                  "startLine": 3188,
                  "startColumn": 37,
                  "endLine": 3188,
                  "endColumn": 53,
                  "charOffset": 110923,
                  "charLength": 16,
                  "snippet": {
                    "text": "http://crbug.com",
                    "rendered": {
                      "text": "http://crbug.com",
                      "markdown": "`http://crbug.com`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 110923,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "https://crbug.com"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "glog-f4526d29-2dc5-4827-a620-c53e4651881b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Insecure URL"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                },
                "region": {
                  "startLine": 2492,
                  "startColumn": 30,
                  "endLine": 2492,
                  "endColumn": 46,
                  "charOffset": 87110,
                  "charLength": 16,
                  "snippet": {
                    "text": "http://crbug.com",
                    "rendered": {
                      "text": "http://crbug.com",
                      "markdown": "`http://crbug.com`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 87110,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "https://crbug.com"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "glog-47334aa6-bad3-4481-bb64-970700c75adc",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Insecure URL"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                },
                "region": {
                  "startLine": 2492,
                  "startColumn": 5,
                  "endLine": 2492,
                  "endColumn": 21,
                  "charOffset": 87085,
                  "charLength": 16,
                  "snippet": {
                    "text": "http://crbug.com",
                    "rendered": {
                      "text": "http://crbug.com",
                      "markdown": "`http://crbug.com`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/gpu/command_buffer/service/gles2_cmd_decoder.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 87085,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "https://crbug.com"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}